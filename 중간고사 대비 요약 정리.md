# Q. 시험 전 질문

- [x] Q. Big-O notation 은 결합/분배법칙이 성립하지 않는 건가요?

  A. 그렇다.

- [x] Q. 병합 정렬에서 병합은 $n-1$번 일어나는데, 왜 시간복잡도는 왜 $O(n^2)$가 아닌가요?

  A. 한 level에서 일어나는 모든 병합과정에서 연산의 횟수의 합이 $O(n)$이다. $O(\log n)$개의 level 만큼 이를 반복하므로, $O(n \log n)$이다. 시각자료에서 병합을 의미하는 화살표 하나가 반드시 연산 1회라는 의미인것이 아니다.

- [ ] Q. Random Access에 대해 더 자세히 설명해주실 수 있나요.

# 1. 자료구조

## 컴퓨터

: (전자) 계산기

### 계산

Computation (계산) = Calculation (연산, CPU) + Memory (기억, 기억장치)

### Turing Machine

: 수학 함수를 이용해서 어떤 값을 구하는 방법이 있다면, 그 방법을 구현할 수 있는 계산 모델

- moving CPU
- R/W device
- memory tape

### Von Neumann architecture

: Stored computer

- Memory
- Control unit
- Arithmetic logic unit

## 자료구조

: (컴퓨터에서) 데이터를 **효율적**으로 **관리**하는 **기법**

- 세상의 모든 데이터 = 숫자 + 문자

데이터 타입:
- system-defined types
- user-defined types

키워드:

- **기법** = 구조 + 연산
- **관리** : 대표연산: 삽입(insert), 삭제(delete), 검색(search)
- **효율적** : $\text{efficiency} = \text{solution}/\text{resource}$
  <sub>(solution을 투입된 resource로 나눈 값)</sub>
    - 시간적 효율성 (CPU)
    - 공간적 효율성 (Memory)
    - 전력적 효율성

자료구조를 왜 C언어로 배워야 하는가: 컴퓨터 내부 구조를 직접 제어할 수 있는 유일한 언어

# 2. 성능 분석

## 좋은 자료구조

1. 정답을 출력할 것
2. 빠른 시간 내에 출력할 것 (= 요구하는 자원이 최소)

## 성능의 세 가지 측면

- 최선의 경우
- 평균의 경우
- **최악의 경우** (= 성능 보장의 의미)

## 복잡도

- **공간 복잡도**: 공간에 관련된 성능 (=요구되는 메모리)
- **시간 복잡도***: 시간에 관련된 성능 (=요구되는 시간)
  <sup>공간 복잡도보다 시간 복잡도가 더 중요하다.</sup>

## 성능을 결정하는 요인

성능은 입력의 크기에 따라 결정 됨

- $n$: 입력의 크기
- 시간 복잡도를 $n$의 함수로 표현: $f(n)$
- 성능 그래프는 $(n, f(n))$으로 표현
- $f(n)$의 종류에는 세 가지가 있다: ($n \to \infty$ 에 따라,)
    - 증가 (대부분이다)
    - 일정 (해쉬가 이에 해당)
    - 감소

## 점근적 분석법 (Asymptotic complexity)

시간 복잡도는 **매우 큰 입력**에 대하여 측정 함.
<sub>reasonably large length of input</sub>

성능 표현에는 표준 함수를 이용한다:
- $1, n$, $\log n$, $n^2$, $n \log n$, $e^n$, $n^n$, ...

성능을 표현하는 다양한 방법:
- $g(n)$이 $f(n)$보다 성능이 나쁠 때:

    - 동일한 크기의 입력을 처리할 때, $g(n)$이 더 많은 시간을 요구
    - $g(n) \geq f(n)$
    - $g(n)$ is the worst case of $f(n)$
    - $f(n)$ is better than $g(n)$
    - The upper bound of $f(n)$ is $g(n)$

## Big-O 표기법

Big-O 표기법은 위의 모두에 해당:
- 최악의 성능에 대하여 나타냄
- 시간 복잡도가 더 중요
- (입력의 크기, 계산시간) = $(n, f(n))$
- 점근적 분석법 사용
- 표준 함수를 사용

### Big-O 의 정의

$$
f(n) \text{ is } O(g(n)) \text{ as } n \to \infty , \text{ if and only if } \\
\exists n_0, \exists M > 0 \text{ such that } f(n) \leq Mg(n) \text{ for } n_0 < n
$$

* 동일한 비율로 증가하는 함수를 허용하기 위해서 상수 $M$을 인정함

> "시간 복잡도 $f(n) = O(n^2)$이다"의 의미:
> - 입력이 $n$ 일 때, 연산 시간이 아무리 걸려도 $n^2$ 이다. (at worst)

### Big-O 의 성질

1. 자신보다 큰 시간복잡도에 자신이 포함된다.
    > $g_1(n) < g_2(n)$ 일 때, $f(n) = O(g_1(n))$ 이라면, $f(n) = O(g_2(n))$ 이기도 하다.
2. 상수항을 무시한다.
    > 어떤 상수 $k$ 에 대해서 $f(n) = O(k \times g(n))$ 이면, $f(n) = O(g(n))$ 이다.
3. 가장 큰 항만을 고려한다.
    > $O(g_1(n) + g_2(n)) = O(g_2(n)) \text{ if } g_1(n) < g_2(n), n > n_1$.

### Big-O 외의 표기법

- $\Omega (n)$: 최선의 경우
- $\Theta (n)$: tight bound, 동일한 비율로 증가 (최선이면서 최악)

## 시간 복잡도

- $O(1)$: 상수(constant) 시간 복잡도 (가장 이상적인 성능)
- $O(n)$: 선형(linear) 시간 복잡도
- $O(n^k)$: 다항(polynomial) 시간 복잡도
- $O(k^n)$: 지수(exponential) 시간 복잡도
- $O(\log n)$: 로그(log) 시간 복잡도

시간 복잡도 비교: ($n$이 충분히 클 때,)
- $1 < \log n < n < n \log n < n^2 < 2^n$
- $O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(n!) < O(n^n)$

시간 복잡도 비교 예시: ($n$명의 학생들이 키 순서대로 앉아있을 때,)
- 맨 앞에 앉아: $O(1)$
- 키에 맞게 자리를 찾아서 앉아: $O(n)$
- 키 순서를 다시 정하자: $O(n^2)$

# 3. 배열

## 리스트

: 원소들을 한 줄로 나열한 구조 (특별한 순서를 따름)

- 유한한 원소들의 나열
- 각 원소들은 인덱스에 대응됨* (가장 중요한 성질)

## 리스트의 구현 방법

- **배열**(Array): **인덱스**에 기반한 구현
    - 메모리에 배열의 크기보다 더 큰 **공간이 허용될 때** 사용
- **연결 리스트**(Linked List): **포인터**에 기반한 구현
    - 메모리에 배열의 크기보다 더 큰 **공간이 없을 때** 사용

<sub>변수: 주소에 1:1 대응되는 니모닉</sub>

## 배열의 기본 연산

(프로그래밍 언어에서 제공)
- 생성 (create)
- 인출 (retrieve)
- 저장 (store)

## 정렬된 배열 vs 정렬되지 않은 배열

- binary search: 정렬된 배열에서만 사용가능
- store, insert, insert by index: