# 정렬

## 리스트 연산

- 추가
- 제거
- 검색

### 제약점

정렬된 리스트의 성능이 더 좋음 (따라서, 리스트를 정렬 해야 함)

## 정렬이란 (sorting)

: 데이터를 정해진 key에 따라서 크기 순으로 배열하는 것

- Ascending order (오름차순, $1, 2, 3, ...$)
- Descending order (내림차순, $9, 8, 7, ...$)

## 정렬 알고리즘의 성능

정렬할 데이터의 개수가 $n$일 때, $O(f(n))$으로 표시한다.

- $O(n^2)$ : 버블 정렬, 삽입 정렬, 선택 정렬, ...
- $O(n \log n)$ : 합병 정렬, 쾌속 정렬, ...

## $O(n^2)$ 정렬

- **이동**에 기반한 정렬
    - 삽입 정렬
- **교환**에 기반한 정렬
    - 버블 정렬
    - 선택 정렬

### 삽입 정렬 (insertion sort)

- 추가 연산(insert)에 기반한다
- 차례로 리스트에 삽입 + 원소를 이동시킴
- 삽입에 $O(n)$이 걸림 ($O(n)$번 원소 교환)
- 삽입을 $O(n)$번 반복
- 최대 $O(n^2)$번의 원소 교환

### 버블 정렬 (bubble sort)

- 가장 뒤에서 부터 작은 값을 앞으로 밀어낸다 -> 가장 작은 값을 맨 앞에 위치시킴
- sinkin sort는 bubble의 역순
- 하나의 자리를 결정하는데 $O(n)$이 걸림 ($O(n)$번 원소 교환)
- $O(n)$개의 자리를 결정함
- 최대 $O(n^2)$번의 원소 교환

### 선택 정렬 (selection sort)

- 최솟 값을 맨 앞으로 옮김
- 최대 $O(n)$번의 원소 교환
- 최솟 값을 찾는데 $O(n)$이 걸림

## $O(n \log n)$ 정렬

- 분할 정복 방식 추구 (분할->정복(예외처리*)->결합)
    - Merge sort
    - Quick sort
- 트리 구조를 이용
    - Heap sort

### 합병 정렬 (Merge sort)

- 과정
    - 분할: n개의 원소를 가진 배열 2개로 분할
    - 정복: 분할 불가능한 것은 정복된 것
    - 결합: 정렬된 배열로 결합
- 재귀호출을 이용한 알고리즘 설계

## 정렬의 성질

- **Comparison**: 비교하여 정렬
    - Comparison이 아닌 것: 기수 정렬
- **Adaptive**: 부분적으로 정렬되어있으면 성능이 좋음
    - ex) insertion, bubble
- **Stable**: 같은 값을 같는 원소들의 자리가 유지
- **In-place**: 추가적으로 요구하는 메모리가 일정
- **Online**: 계속 증가하는 데이터에도 가능
    - ex) insertion, bubble
